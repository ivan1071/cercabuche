<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#ef4444">
    <title>RoadBumps Tracker</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; overscroll-behavior: none; }
        #map { height: 45vh; width: 100%; z-index: 1; }
        
        .glass-panel { background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(10px); }
        
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }
        .bump-alert { animation: shake 0.5s; }
        .sensor-bar { transition: width 0.1s ease; }
        
        /* FIX Z-INDEX: Modali sopra tutto */
        .modal-overlay {
            position: fixed; 
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.6); 
            z-index: 9999; /* Superiore alla mappa (Leaflet usa 1000) */
            display: none; 
            align-items: center; 
            justify-content: center; 
            padding: 1rem;
        }
        .modal-overlay.active { display: flex; }
        .modal-box {
            background: white; 
            border-radius: 1rem; 
            padding: 1.5rem;
            max-width: 400px; 
            width: 100%; 
            max-height: 80vh; 
            overflow-y: auto;
            z-index: 10000; /* Massima priorit√† */
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
        }
    </style>
</head>
<body class="bg-gray-100 h-screen flex flex-col overflow-hidden">

    <div class="glass-panel shadow-lg z-20 px-4 py-2 flex items-center justify-between border-b border-gray-200">
        <div class="flex items-center gap-2">
            <div class="bg-red-500 text-white p-2 rounded-lg"><i data-lucide="alert-triangle" class="w-5 h-5"></i></div>
            <div>
                <h1 class="font-bold text-gray-800 text-base">RoadBumps</h1>
                <p class="text-xs text-gray-500" id="stats-text">Pronto</p>
            </div>
        </div>
        <div class="flex items-center gap-2">
            <div id="status-indicator" class="w-3 h-3 rounded-full bg-gray-400"></div>
            <span id="status-text" class="text-xs font-medium text-gray-600">Standby</span>
        </div>
    </div>

    <div id="map" class="shadow-inner"></div>

    <div class="flex-1 glass-panel flex flex-col overflow-hidden">
        <div class="p-3 border-b border-gray-200 flex gap-2 overflow-x-auto">
            <button id="btn-main" onclick="toggleMain()" class="flex-1 bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-3 rounded-lg flex items-center justify-center gap-2 transition-all active:scale-95 shadow-lg text-sm">
                <i data-lucide="play" class="w-4 h-4"></i><span>Avvia</span>
            </button>
            <button id="btn-stop" onclick="stopAll()" class="hidden bg-gray-600 hover:bg-gray-700 text-white font-semibold py-2 px-3 rounded-lg flex items-center gap-2 text-sm">
                <i data-lucide="x" class="w-4 h-4"></i><span>Termina</span>
            </button>
            <button onclick="openImportModal()" class="bg-purple-500 hover:bg-purple-600 text-white p-2 rounded-lg shadow-lg">
                <i data-lucide="upload" class="w-4 h-4"></i>
            </button>
            <button onclick="openExportModal()" class="bg-blue-500 hover:bg-blue-600 text-white p-2 rounded-lg shadow-lg">
                <i data-lucide="download" class="w-4 h-4"></i>
            </button>
            <button onclick="recenterMap()" class="bg-indigo-500 hover:bg-indigo-600 text-white p-2 rounded-lg" title="Centra">
                <i data-lucide="crosshair" class="w-4 h-4"></i>
            </button>
            <button onclick="clearData()" class="bg-gray-500 hover:bg-gray-600 text-white p-2 rounded-lg">
                <i data-lucide="trash-2" class="w-4 h-4"></i>
            </button>
        </div>

        <div class="px-3 py-2 bg-gray-50 border-b border-gray-200 space-y-2">
            <div class="flex items-center justify-between">
                <span class="text-xs font-semibold text-gray-600">Soglia</span>
                <select id="threshold-select" onchange="updateThreshold()" class="text-xs border rounded px-2 py-1 bg-white">
                    <option value="8">8 m/s¬≤</option>
                    <option value="10">10</option>
                    <option value="12" selected>12 (Standard)</option>
                    <option value="15">15</option>
                    <option value="20">20</option>
                </select>
            </div>
            <div class="flex items-center gap-2">
                <input type="checkbox" id="follow-toggle" class="w-4 h-4 rounded border-gray-300" checked>
                <label for="follow-toggle" class="text-xs text-gray-600">Segui posizione</label>
            </div>
            <div class="flex items-center gap-2">
                <input type="checkbox" id="privacy-toggle" class="w-4 h-4 rounded border-gray-300" checked>
                <label for="privacy-toggle" class="text-xs text-gray-600">Privacy offset ¬±10m su export</label>
            </div>
        </div>

        <div class="px-3 py-2 bg-gray-50 border-b border-gray-200">
            <div class="flex justify-between mb-1">
                <span class="text-xs font-semibold text-gray-600">Intensit√†</span>
                <span id="g-force" class="text-sm font-bold text-gray-800">0.0g</span>
            </div>
            <div class="w-full bg-gray-200 rounded-full h-2 overflow-hidden">
                <div id="intensity-bar" class="sensor-bar bg-gradient-to-r from-green-400 via-yellow-400 to-red-500 h-full" style="width: 0%"></div>
            </div>
        </div>

        <div class="flex-1 overflow-y-auto p-3 space-y-2" id="bumps-list">
            <div class="text-center text-gray-400 py-4">
                <i data-lucide="map-pin" class="w-8 h-8 mx-auto mb-1 opacity-20"></i>
                <p class="text-xs">Nessun dissesto</p>
            </div>
        </div>

        <div id="alert-banner" class="hidden bg-red-500 text-white p-3 shadow-lg">
            <div class="flex items-center gap-2">
                <i data-lucide="alert-octagon" class="w-5 h-5 animate-bounce"></i>
                <div class="flex-1">
                    <p class="font-bold text-sm" id="alert-title">ATTENZIONE!</p>
                    <p class="text-xs opacity-90" id="alert-desc">Rallentare</p>
                </div>
                <button onclick="hideAlert()" class="p-1 hover:bg-white/20 rounded"><i data-lucide="x" class="w-4 h-4"></i></button>
            </div>
        </div>
    </div>

    <!-- Modal Export -->
    <div id="export-modal" class="modal-overlay">
        <div class="modal-box">
            <h3 class="font-bold text-lg mb-3">Esporta</h3>
            <div id="city-detecting" class="text-sm text-gray-600 mb-3">
                <span class="animate-pulse">üîç Rilevamento citt√†...</span>
            </div>
            <div id="city-detected" class="hidden mb-3">
                <input type="text" id="export-city" class="w-full border rounded px-3 py-2 text-sm bg-gray-50" readonly>
            </div>
            <div class="flex items-center gap-2 mb-4">
                <input type="checkbox" id="export-privacy" class="w-4 h-4 rounded border-gray-300" checked>
                <label for="export-privacy" class="text-xs text-gray-600">Privacy offset ¬±10m</label>
            </div>
            <div class="flex gap-2">
                <button onclick="confirmExport()" class="flex-1 bg-blue-500 hover:bg-blue-600 text-white py-2 rounded-lg font-semibold text-sm">Esporta</button>
                <button onclick="closeModal('export-modal')" class="flex-1 bg-gray-200 hover:bg-gray-300 text-gray-700 py-2 rounded-lg font-semibold text-sm">Annulla</button>
            </div>
        </div>
    </div>

    <!-- Modal Import -->
    <div id="import-modal" class="modal-overlay">
        <div class="modal-box">
            <h3 class="font-bold text-lg mb-3">Importa</h3>
            <input type="file" id="import-input" accept=".json" class="w-full text-xs border rounded p-2 bg-white mb-3">
            <div class="mb-3">
                <label class="text-xs font-semibold text-gray-600 block mb-1">Solo entro: <span id="km-value">20</span> km</label>
                <input type="range" id="import-radius" min="5" max="50" value="20" class="w-full" oninput="document.getElementById('km-value').textContent = this.value">
            </div>
            <div class="flex gap-2">
                <button onclick="confirmImport()" class="flex-1 bg-purple-500 hover:bg-purple-600 text-white py-2 rounded-lg font-semibold text-sm">Importa</button>
                <button onclick="closeModal('import-modal')" class="flex-1 bg-gray-200 hover:bg-gray-300 text-gray-700 py-2 rounded-lg font-semibold text-sm">Annulla</button>
            </div>
        </div>
    </div>

    <script>
        lucide.createIcons();

        let isRecording = false;
        let isNavigating = false;
        let map, userMarker, pathLine;
        let accelerometer = null;
        let geolocationId = null;
        let detectedBumps = [];
        let currentPosition = null;
        let pathCoordinates = [];
        let lastPosition = null;
        let currentSpeed = 0;
        let lastBumpTime = 0;
        let proximityCheckInterval;
        let BUMP_THRESHOLD = 12;
        const COOLDOWN_MS = 3000;
        const CLUSTER_RADIUS = 8;
        let userHasMovedMap = false;

        try {
            const stored = localStorage.getItem('roadBumps');
            if (stored) {
                const parsed = JSON.parse(stored);
                if (Array.isArray(parsed)) {
                    detectedBumps = parsed.filter(b => b && b.id && !isNaN(b.lat) && !isNaN(b.lng));
                }
            }
        } catch (e) { detectedBumps = []; }

        document.addEventListener('DOMContentLoaded', () => {
            initMap();
            renderBumpsList();
            updateStats();
        });

        function updateThreshold() {
            BUMP_THRESHOLD = parseInt(document.getElementById('threshold-select').value);
        }

        function initMap() {
            map = L.map('map').setView([41.9028, 12.4964], 13);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap', maxZoom: 19
            }).addTo(map);
            
            map.on('dragstart', () => { userHasMovedMap = true; });
            renderAllMarkers();
        }

        function updateStats() {
            document.getElementById('stats-text').textContent = `${detectedBumps.length} dissesti`;
        }

        // FUNZIONI PRINCIPALI: Avvia/Stop/Riprendi
        async function toggleMain() {
            if (!isNavigating && !isRecording) {
                // Da Standby a Registrazione
                await startRecordingAndNav();
            } else if (isRecording) {
                // Da Registrazione a Navigazione (solo avvisi)
                stopRecordingOnly();
            } else if (isNavigating && !isRecording) {
                // Da Navigazione a Registrazione (riprendi)
                await startRecordingOnly();
            }
            updateUI();
        }

        function stopAll() {
            isNavigating = false;
            isRecording = false;
            if (geolocationId) navigator.geolocation.clearWatch(geolocationId);
            if (accelerometer) { accelerometer.stop(); accelerometer = null; }
            if (proximityCheckInterval) clearInterval(proximityCheckInterval);
            updateUI();
            hideAlert();
        }

        async function startRecordingAndNav() {
            if (!navigator.geolocation) throw new Error('GPS non supportato');
            
            geolocationId = navigator.geolocation.watchPosition(
                (pos) => {
                    const newPos = {
                        lat: pos.coords.latitude,
                        lng: pos.coords.longitude,
                        timestamp: Date.now(),
                        speed: pos.coords.speed
                    };
                    
                    if (lastPosition && !isNaN(lastPosition.lat) && !isNaN(lastPosition.lng)) {
                        const dist = calculateDistance(lastPosition.lat, lastPosition.lng, newPos.lat, newPos.lng);
                        const timeDiff = (newPos.timestamp - lastPosition.timestamp) / 1000;
                        if (timeDiff > 0) currentSpeed = (dist / timeDiff) * 3.6;
                    } else if (newPos.speed) {
                        currentSpeed = newPos.speed * 3.6;
                    }
                    
                    currentPosition = newPos;
                    lastPosition = newPos;
                    updateUserPosition(newPos);
                    
                    pathCoordinates.push([newPos.lat, newPos.lng]);
                    if (pathLine) pathLine.setLatLngs(pathCoordinates);
                    else pathLine = L.polyline(pathCoordinates, {color: 'blue', weight: 4}).addTo(map);
                },
                (err) => console.error('GPS Error:', err),
                { enableHighAccuracy: true, maximumAge: 1000, timeout: 5000 }
            );
            
            await startAccelerometer();
            proximityCheckInterval = setInterval(checkProximity, 3000);
            isRecording = true;
            isNavigating = true;
        }

        async function startRecordingOnly() {
            await startAccelerometer();
            isRecording = true;
        }

        function stopRecordingOnly() {
            if (accelerometer) { accelerometer.stop(); accelerometer = null; }
            isRecording = false;
        }

        async function startAccelerometer() {
            if ('Accelerometer' in window) {
                try {
                    if (navigator.permissions) {
                        const res = await navigator.permissions.query({ name: 'accelerometer' });
                        if (res.state === 'denied') throw new Error('Permesso negato');
                    }
                    accelerometer = new Accelerometer({ frequency: 60 });
                    accelerometer.addEventListener('reading', () => {
                        processAccel(accelerometer.x, accelerometer.y, accelerometer.z);
                    });
                    accelerometer.start();
                } catch (e) { console.warn('Accelerometro non disponibile:', e); }
            }
        }

        function processAccel(x, y, z) {
            if (!currentPosition) return;
            const verticalAccel = Math.abs((z || 0) - 9.8);
            const intensity = Math.min((verticalAccel / 20) * 100, 100);
            
            document.getElementById('intensity-bar').style.width = `${intensity}%`;
            document.getElementById('g-force').textContent = `${(verticalAccel / 9.8).toFixed(1)}g`;
            
            const now = Date.now();
            if (verticalAccel > BUMP_THRESHOLD && (now - lastBumpTime > COOLDOWN_MS)) {
                lastBumpTime = now;
                registerBump(currentPosition, verticalAccel);
            }
        }

        function registerBump(position, intensity) {
            const now = Date.now();
            const duplicate = detectedBumps.find(b => {
                if (!b || !b.lat || !b.lng) return false;
                const dist = calculateDistance(position.lat, position.lng, b.lat, b.lng);
                return dist < CLUSTER_RADIUS && (now - b.id) < 10000;
            });
            
            if (duplicate) {
                if (intensity > duplicate.intensity) {
                    duplicate.intensity = intensity;
                    duplicate.type = intensity > 30 ? 'buca_profonda' : (intensity > 20 ? 'dosso' : 'sussulto_medio');
                    saveData();
                    renderBumpsList();
                }
                return;
            }
            
            let type = 'sussulto_medio';
            if (intensity > 30) type = 'buca_profonda';
            else if (intensity > 20) type = 'dosso';
            
            const bump = {
                id: now,
                lat: position.lat,
                lng: position.lng,
                intensity: intensity,
                timestamp: new Date().toISOString(),
                type: type,
                fromImport: false
            };
            
            detectedBumps.push(bump);
            saveData();
            addBumpMarker(bump);
            renderBumpsList();
            updateStats();
        }

        function saveData() {
            localStorage.setItem('roadBumps', JSON.stringify(detectedBumps));
        }

        function updateUI() {
            const btnMain = document.getElementById('btn-main');
            const btnStop = document.getElementById('btn-stop');
            const statusInd = document.getElementById('status-indicator');
            const statusText = document.getElementById('status-text');
            
            btnMain.className = 'flex-1 font-semibold py-2 px-3 rounded-lg flex items-center justify-center gap-2 transition-all active:scale-95 shadow-lg text-sm';
            
            if (!isNavigating && !isRecording) {
                btnMain.innerHTML = '<i data-lucide="play" class="w-4 h-4"></i><span>Avvia</span>';
                btnMain.classList.add('bg-green-500', 'text-white');
                btnStop.classList.add('hidden');
                statusInd.className = 'w-3 h-3 rounded-full bg-gray-400';
                statusText.textContent = 'Standby';
            } else if (isRecording) {
                btnMain.innerHTML = '<i data-lucide="square" class="w-4 h-4"></i><span>Stop</span>';
                btnMain.classList.add('bg-red-500', 'text-white');
                btnStop.classList.remove('hidden');
                statusInd.className = 'w-3 h-3 rounded-full bg-green-500 animate-pulse';
                statusText.textContent = 'Registrazione...';
            } else {
                btnMain.innerHTML = '<i data-lucide="refresh-cw" class="w-4 h-4"></i><span>Riprendi</span>';
                btnMain.classList.add('bg-blue-500', 'text-white');
                btnStop.classList.remove('hidden');
                statusInd.className = 'w-3 h-3 rounded-full bg-blue-500 animate-pulse';
                statusText.textContent = 'Navigazione';
            }
            lucide.createIcons();
        }

        function updateUserPosition(pos) {
            if (!userMarker) {
                userMarker = L.circleMarker([pos.lat, pos.lng], {
                    radius: 6, fillColor: "#3b82f6", color: "#fff", weight: 2, fillOpacity: 0.8
                }).addTo(map);
            } else {
                userMarker.setLatLng([pos.lat, pos.lng]);
            }
            
            const autoFollow = document.getElementById('follow-toggle')?.checked ?? true;
            if (autoFollow && !userHasMovedMap) {
                map.setView([pos.lat, pos.lng], 17);
            }
        }

        function recenterMap() {
            if (currentPosition) {
                map.setView([currentPosition.lat, currentPosition.lng], 17);
                userHasMovedMap = false;
            }
        }

        // REVERSE GEOCODING
        async function detectCityName() {
            let lat, lng;
            if (detectedBumps.length > 0) {
                lat = detectedBumps[0].lat;
                lng = detectedBumps[0].lng;
            } else if (currentPosition) {
                lat = currentPosition.lat;
                lng = currentPosition.lng;
            } else {
                return "RoadBumps";
            }
            
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lng}&format=json&accept-language=it`);
                const data = await response.json();
                const address = data.address || {};
                const city = address.city || address.town || address.village || address.county || "Localita";
                return city.replace(/Citt√† Metropolitana di /i, '').replace(/Provincia di /i, '');
            } catch (e) {
                return "RoadBumps";
            }
        }

        // EXPORT / IMPORT
        async function openExportModal() {
            if (detectedBumps.length === 0) {
                alert('Nessun dato');
                return;
            }
            document.getElementById('export-modal').classList.add('active');
            document.getElementById('city-detecting').classList.remove('hidden');
            document.getElementById('city-detected').classList.add('hidden');
            
            const city = await detectCityName();
            const dateStr = new Date().toISOString().split('T')[0];
            document.getElementById('export-city').value = `${city}_${dateStr}`;
            
            document.getElementById('city-detecting').classList.add('hidden');
            document.getElementById('city-detected').classList.remove('hidden');
        }

        function openImportModal() {
            document.getElementById('import-modal').classList.add('active');
        }

        function closeModal(id) {
            document.getElementById(id).classList.remove('active');
        }

        function confirmExport() {
            const city = document.getElementById('export-city').value || 'RoadBumps';
            const privacyOn = document.getElementById('export-privacy')?.checked;
            let dataToExport = detectedBumps;
            
            if (privacyOn) {
                dataToExport = detectedBumps.map(b => ({
                    ...b,
                    lat: b.lat + (Math.random() - 0.5) * 0.00018,
                    lng: b.lng + (Math.random() - 0.5) * 0.00018,
                    privacyFuzzed: true
                }));
            }
            
            const dataStr = JSON.stringify(dataToExport, null, 2);
            const blob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${city}.json`;
            link.click();
            closeModal('export-modal');
        }

        function confirmImport() {
            const input = document.getElementById('import-input');
            const file = input.files[0];
            if (!file) return alert('Seleziona un file');
            
            const radiusKm = parseInt(document.getElementById('import-radius').value);
            
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const imported = JSON.parse(e.target.result);
                    if (!Array.isArray(imported)) throw new Error('Formato non valido');
                    
                    let added = 0, merged = 0, skipped = 0;
                    
                    imported.forEach(imp => {
                        if (!imp || !imp.lat || !imp.lng || isNaN(imp.lat) || isNaN(imp.lng)) return;
                        
                        if (currentPosition && radiusKm) {
                            const dist = calculateDistance(currentPosition.lat, currentPosition.lng, imp.lat, imp.lng);
                            if (dist > radiusKm * 1000) {
                                skipped++;
                                return;
                            }
                        }
                        
                        const duplicate = detectedBumps.find(b => {
                            if (!b || !b.lat || !b.lng) return false;
                            return calculateDistance(b.lat, b.lng, imp.lat, imp.lng) < 8;
                        });
                        
                        if (duplicate) {
                            if ((imp.intensity || 0) > (duplicate.intensity || 0)) {
                                duplicate.intensity = imp.intensity;
                                duplicate.type = imp.type;
                            }
                            merged++;
                        } else {
                            detectedBumps.push({
                                id: Date.now() + Math.random(),
                                lat: parseFloat(imp.lat),
                                lng: parseFloat(imp.lng),
                                intensity: parseFloat(imp.intensity) || 15,
                                timestamp: imp.timestamp || new Date().toISOString(),
                                type: imp.type || 'dosso',
                                fromImport: true
                            });
                            added++;
                        }
                    });
                    
                    saveData();
                    renderAllMarkers();
                    renderBumpsList();
                    updateStats();
                    closeModal('import-modal');
                    alert(`Importazione:\n${added} nuovi\n${merged} aggiornati\n${skipped} scartati (oltre ${radiusKm}km)`);
                    input.value = '';
                } catch (err) {
                    alert('Errore: ' + err.message);
                }
            };
            reader.readAsText(file);
        }

        function renderAllMarkers() {
            map.eachLayer(layer => {
                if (layer instanceof L.Marker && layer !== userMarker) map.removeLayer(layer);
            });
            detectedBumps.forEach(b => { if (b && b.lat && b.lng) addBumpMarker(b); });
        }

        function addBumpMarker(bump) {
            const isImport = bump.fromImport;
            const intensity = parseFloat(bump.intensity) || 0;
            const color = intensity > 25 ? (isImport ? 'purple' : 'red') : 'orange';
            
            const icon = L.divIcon({
                html: `<div style="background-color: ${color}; width: 10px; height: 10px; border-radius: 50%; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>`,
                iconSize: [10, 10], iconAnchor: [5, 5]
            });
            
            const marker = L.marker([bump.lat, bump.lng], { icon }).addTo(map);
            const typeLabel = bump.type === 'buca_profonda' ? 'Buca Profonda' : (bump.type === 'dosso' ? 'Dosso' : 'Sussulto');
            const gForce = (intensity / 9.8).toFixed(1);
            
            marker.bindPopup(`<div class="text-xs"><strong>${typeLabel}</strong><br>Intensit√†: ${gForce}g<br><small>${new Date(bump.timestamp).toLocaleString()}</small></div>`);
        }

        function checkProximity() {
            if (!currentPosition || detectedBumps.length === 0 || !isNavigating) return;
            
            let warningDist = 150;
            if (currentSpeed > 0) {
                warningDist = Math.max(80, Math.min(300, (currentSpeed / 3.6) * 20));
            }
            
            let nearest = null;
            let minDist = Infinity;
            
            detectedBumps.forEach(bump => {
                if (!bump || isNaN(bump.lat) || isNaN(bump.lng)) return;
                const dist = calculateDistance(currentPosition.lat, currentPosition.lng, bump.lat, bump.lng);
                if (dist < minDist && dist < warningDist) {
                    minDist = dist;
                    nearest = bump;
                }
            });
            
            if (nearest) {
                const timeArrival = currentSpeed > 0 ? Math.round(minDist / (currentSpeed / 3.6)) : 0;
                showAlert(nearest, minDist, timeArrival);
            } else {
                hideAlert();
            }
        }

        function calculateDistance(lat1, lon1, lat2, lon2) {
            const p1 = parseFloat(lat1);
            const p2 = parseFloat(lon1);
            const p3 = parseFloat(lat2);
            const p4 = parseFloat(lon2);
            
            if (isNaN(p1) || isNaN(p2) || isNaN(p3) || isNaN(p4)) return Infinity;
            
            const R = 6371000;
            const œÜ1 = p1 * Math.PI/180;
            const œÜ2 = p3 * Math.PI/180;
            const ŒîœÜ = (p3-p1) * Math.PI/180;
            const ŒîŒª = (p4-p2) * Math.PI/180;
            const a = Math.sin(ŒîœÜ/2)**2 + Math.cos(œÜ1)*Math.cos(œÜ2)*Math.sin(ŒîŒª/2)**2;
            return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        }

        function showAlert(bump, distance, seconds) {
            const banner = document.getElementById('alert-banner');
            const title = document.getElementById('alert-title');
            const desc = document.getElementById('alert-desc');
            
            if (!banner || !title || !desc || !bump) return;
            
            const tipo = bump.type === 'buca_profonda' ? 'Buca profonda' : (bump.type === 'dosso' ? 'Dosso' : 'Dissesto');
            const dist = Math.round(parseFloat(distance) || 0);
            const secs = parseInt(seconds) || 0;
            
            // Template literal: no concatenazione con +
            title.textContent = `‚ö†Ô∏è ${tipo} tra ${dist}m${secs > 0 ? ` (${secs}s)` : ''}`;
            
            const speed = parseFloat(currentSpeed) || 0;
            desc.textContent = speed > 5 ? `Rallenta! ${Math.round(speed)} km/h` : 'Rallentare';
            
            if (banner.classList.contains('hidden')) {
                banner.classList.remove('hidden');
                if (navigator.vibrate) navigator.vibrate([200, 100, 200]);
            }
        }

        function hideAlert() {
            const banner = document.getElementById('alert-banner');
            if (banner) banner.classList.add('hidden');
        }

        function renderBumpsList() {
            const container = document.getElementById('bumps-list');
            if (!container) return;
            
            if (!detectedBumps || detectedBumps.length === 0) {
                container.innerHTML = `<div class="text-center text-gray-400 py-4"><i data-lucide="map-pin" class="w-8 h-8 mx-auto mb-1 opacity-20"></i><p class="text-xs">Nessun dissesto</p></div>`;
                lucide.createIcons();
                return;
            }
            
            const sorted = [...detectedBumps]
                .filter(b => b && !isNaN(b.lat) && !isNaN(b.lng))
                .sort((a, b) => (b.id || 0) - (a.id || 0));
            
            container.innerHTML = sorted.map(bump => {
                const intensity = parseFloat(bump.intensity) || 0;
                const isImport = bump.fromImport;
                const colorClass = intensity > 25 ? (isImport ? 'bg-purple-100 text-purple-600' : 'bg-red-100 text-red-600') : 'bg-orange-100 text-orange-600';
                const gForce = (intensity / 9.8).toFixed(1);
                
                let typeLabel = 'Sussulto';
                if (bump.type === 'buca_profonda') typeLabel = 'Buca';
                else if (bump.type === 'dosso') typeLabel = 'Dosso';
                
                return `
                <div class="bg-white rounded-lg p-2 shadow-sm border border-gray-200 flex items-center gap-2">
                    <div class="w-8 h-8 rounded-full ${colorClass} flex items-center justify-center shrink-0">
                        <i data-lucide="${intensity > 25 ? 'alert-triangle' : 'alert-circle'}" class="w-4 h-4"></i>
                    </div>
                    <div class="flex-1 min-w-0">
                        <p class="font-semibold text-gray-800 text-xs">${typeLabel}${isImport ? ' (imp.)' : ''}</p>
                        <p class="text-xs text-gray-500">${gForce}g</p>
                    </div>
                    <button onclick="centerOnBump(${parseFloat(bump.lat)}, ${parseFloat(bump.lng)})" class="p-1 hover:bg-gray-100 rounded text-gray-400 hover:text-blue-500">
                        <i data-lucide="map-pin" class="w-3 h-3"></i>
                    </button>
                </div>
                `;
            }).join('');
            
            lucide.createIcons();
        }

        function centerOnBump(lat, lng) {
            if (isNaN(lat) || isNaN(lng)) return alert('Coordinate non valide');
            map.setView([lat, lng], 18);
        }

        function clearData() {
            if (confirm('Cancellare tutti i dati?')) {
                detectedBumps = [];
                localStorage.removeItem('roadBumps');
                map.eachLayer(layer => {
                    if (layer instanceof L.Marker && layer !== userMarker) map.removeLayer(layer);
                });
                renderBumpsList();
                updateStats();
                hideAlert();
            }
        }

        window.addEventListener('beforeunload', (e) => {
            if (isRecording || isNavigating) {
                e.preventDefault();
                e.returnValue = 'Stai registrando. Uscire?';
            }
        });
    </script>
</body>
</html>
